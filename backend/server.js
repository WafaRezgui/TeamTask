const express = require('express');
const mongoose = require('mongoose');
const dotenv = require('dotenv');
const cors = require('cors');
const User = require('./models/User');

// Charger les variables d'environnement
dotenv.config();

console.log('üîÑ D√©marrage TeamTask Backend...');

const app = express();

// ----- CORS -----
app.use(cors({
  origin: (origin, callback) => {
    if (!origin || origin.startsWith('http://localhost') || origin.startsWith('https://localhost')) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true
}));

// ----- Middleware -----
app.use(express.json());

app.use((req, res, next) => {
  console.log(`üì° ${req.method} ${req.path}`);
  console.log('üì¶ Body:', req.body);
  next();
});

// ----- Connexion MongoDB -----
const connectDB = async () => {
  try {
    console.log('üîÑ Connexion √† MongoDB...');
    
    await mongoose.connect(process.env.MONGO_URI, {
      serverSelectionTimeoutMS: 10000,
      socketTimeoutMS: 45000,
      bufferCommands: false,
      maxPoolSize: 10
    });
    
    console.log('‚úÖ Connect√© √† MongoDB Atlas');
    return true;
    
  } catch (error) {
    console.error('‚ùå Erreur de connexion √† MongoDB :', error.message);
    return false;
  }
};

// ----- Fonction pour charger les routes -----
const loadRoutes = async () => {
  try {
    console.log('üîÑ Chargement des routes...');

    // IMPORTANT: Import TaskHistory APR√àS la connexion MongoDB
    const TaskHistory = require('./models/TaskHistory');
    console.log('‚úÖ TaskHistory model charg√© apr√®s connexion DB');

    // V√©rifier que TaskHistory est bien un mod√®le Mongoose
    if (!TaskHistory || typeof TaskHistory.countDocuments !== 'function') {
      throw new Error('TaskHistory n\'est pas un mod√®le Mongoose valide');
    }

    // Import des routes et middlewares
    const authRoutes = require('./routes/authRoutes');
    console.log('‚úÖ authRoutes charg√©');

    const taskRoutes = require('./routes/taskRoutes');
    console.log('‚úÖ taskRoutes charg√©');

    const historyRoutes = require('./routes/historyRoutes');
    console.log('‚úÖ historyRoutes charg√©');

    const { getTaskHistory } = require('./utils/taskHistory');
    console.log('‚úÖ taskHistory utils charg√©');

    // Monter les routes principales
    app.use('/api/auth', authRoutes);
    app.use('/api/tasks', taskRoutes);
    app.use('/api/history', historyRoutes);
    console.log('‚úÖ Routes mont√©es sur /api/auth, /api/tasks, /api/history');

    // ----- Route utilisateurs -----
    app.get('/api/users', async (req, res) => {
      try {
        const users = await User.find();
        res.json({
          success: true,
          count: users.length,
          data: users
        });
      } catch (error) {
        console.error('‚ùå Erreur r√©cup√©ration utilisateurs:', error.message);
        res.status(500).json({ 
          success: false,
          message: 'Erreur lors de la r√©cup√©ration des utilisateurs',
          error: error.message
        });
      }
    });
    console.log('‚úÖ Endpoint /api/users ajout√©');

    // ----- Route de test TaskHistory direct -----
    app.get('/test-taskhistory-direct', async (req, res) => {
      try {
        console.log('=== DIAGNOSTIC TASKHISTORY ===');
        console.log('Type de TaskHistory:', typeof TaskHistory);
        console.log('Constructor:', TaskHistory.constructor.name);
        console.log('countDocuments:', typeof TaskHistory.countDocuments);
        console.log('√âtat connexion MongoDB:', mongoose.connection.readyState);
        
        // Test direct de countDocuments
        const count = await TaskHistory.countDocuments();
        console.log('Count r√©ussi:', count);
        
        // Test de cr√©ation d'une entr√©e de test
        const testEntry = new TaskHistory({
          taskId: new mongoose.Types.ObjectId(),
          userId: new mongoose.Types.ObjectId(),
          action: 'created',
          description: 'Test de diagnostic'
        });
        
        res.json({
          success: true,
          taskHistoryType: typeof TaskHistory,
          constructor: TaskHistory.constructor.name,
          hasCountDocuments: typeof TaskHistory.countDocuments === 'function',
          mongooseConnection: mongoose.connection.readyState,
          actualCount: count,
          canCreateInstance: !!testEntry,
          message: '‚úÖ Diagnostic TaskHistory r√©ussi - Mod√®le fonctionnel'
        });
      } catch (error) {
        console.error('Erreur diagnostic TaskHistory:', error);
        res.status(500).json({
          success: false,
          error: error.message,
          stack: error.stack,
          message: '‚ùå Diagnostic TaskHistory √©chou√©'
        });
      }
    });

    // ----- Route de test sans authentification pour l'historique -----
    app.get('/api/history-no-auth', async (req, res) => {
      try {
        console.log('üìä Test historique sans authentification...');
        
        // V√©rifier d'abord que TaskHistory fonctionne
        if (typeof TaskHistory.countDocuments !== 'function') {
          throw new Error('TaskHistory.countDocuments is not a function');
        }
        
        const historyCount = await TaskHistory.countDocuments();
        console.log(`Nombre total d'entr√©es: ${historyCount}`);
        
        const history = await TaskHistory.find()
          .populate('userId', 'username')
          .populate('taskId', 'title')
          .sort({ createdAt: -1 })
          .limit(10);
        
        res.json({
          success: true,
          message: 'Test historique sans auth r√©ussi',
          totalEntries: historyCount,
          data: history,
          count: history.length
        });
      } catch (error) {
        console.error('‚ùå Erreur test historique:', error);
        res.status(500).json({
          success: false,
          message: 'Erreur lors du test historique',
          error: error.message,
          details: {
            taskHistoryType: typeof TaskHistory,
            hasCountDocuments: TaskHistory && typeof TaskHistory.countDocuments === 'function'
          }
        });
      }
    });
    console.log('‚úÖ Route test historique sans auth ajout√©e');

    // ----- Routes de test et debug -----
    app.get('/', (req, res) => {
      res.json({
        message: 'Bienvenue sur TeamTask API üöÄ',
        version: '1.0.0',
        status: 'active',
        mongodb: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected'
      });
    });

    app.get('/test', (req, res) => {
      res.json({ 
        message: 'TEST MARCHE !', 
        timestamp: new Date(),
        mongodb: mongoose.connection.readyState
      });
    });

    app.get('/debug-users', (req, res) => {
      res.json({ 
        message: 'Route debug fonctionne!', 
        timestamp: new Date(),
        mongodb: mongoose.connection.readyState
      });
    });

    // ----- Route debug historique corrig√©e -----
    app.get('/debug-history', async (req, res) => {
      try {
        console.log('=== DEBUG HISTORIQUE ===');
        console.log('Type de TaskHistory:', typeof TaskHistory);
        console.log('Constructor:', TaskHistory.constructor.name);
        console.log('countDocuments existe:', typeof TaskHistory.countDocuments);
        console.log('√âtat MongoDB:', mongoose.connection.readyState);
        
        // V√©rification des pr√©requis
        if (!TaskHistory) {
          return res.json({
            success: false,
            error: 'TaskHistory is undefined',
            debug: 'Le mod√®le TaskHistory n\'a pas √©t√© import√© correctement'
          });
        }
        
        if (typeof TaskHistory.countDocuments !== 'function') {
          return res.json({
            success: false,
            error: 'TaskHistory.countDocuments is not a function',
            taskHistoryType: typeof TaskHistory,
            constructor: TaskHistory.constructor.name,
            mongooseState: mongoose.connection.readyState,
            debug: 'Le mod√®le TaskHistory n\'est pas correctement initialis√© comme mod√®le Mongoose'
          });
        }

        // Tests fonctionnels
        const historyCount = await TaskHistory.countDocuments();
        console.log(`Total d'entr√©es: ${historyCount}`);
        
        const recentHistory = await TaskHistory.find()
          .sort({ createdAt: -1 })
          .limit(5);
        
        console.log(`Entr√©es r√©centes trouv√©es: ${recentHistory.length}`);
        
        res.json({
          success: true,
          message: '‚úÖ Debug historique fonctionne parfaitement!',
          totalEntries: historyCount,
          recentEntries: recentHistory,
          modelInfo: {
            type: typeof TaskHistory,
            constructor: TaskHistory.constructor.name,
            hasMethods: typeof TaskHistory.countDocuments === 'function'
          },
          mongooseInfo: {
            connectionState: mongoose.connection.readyState,
            connectionName: mongoose.connection.name
          },
          timestamp: new Date()
        });
      } catch (error) {
        console.error('‚ùå Erreur debug historique:', error);
        res.status(500).json({
          success: false,
          message: 'Erreur debug historique',
          error: error.message,
          stack: error.stack,
          debug: 'Erreur lors de l\'ex√©cution des requ√™tes MongoDB'
        });
      }
    });

    // ----- Route pour cr√©er une entr√©e de test -----
    app.post('/api/history-test-create', async (req, res) => {
      try {
        const testEntry = new TaskHistory({
          taskId: new mongoose.Types.ObjectId(),
          userId: new mongoose.Types.ObjectId(), 
          action: 'created',
          description: `Test automatique - ${new Date().toISOString()}`
        });
        
        await testEntry.save();
        console.log('‚úÖ Entr√©e de test cr√©√©e:', testEntry._id);
        
        res.json({
          success: true,
          message: 'Entr√©e d\'historique de test cr√©√©e avec succ√®s',
          data: testEntry
        });
      } catch (error) {
        console.error('‚ùå Erreur cr√©ation test:', error);
        res.status(500).json({
          success: false,
          message: 'Erreur lors de la cr√©ation de l\'entr√©e de test',
          error: error.message
        });
      }
    });

    // ----- Gestion des erreurs -----
    app.use((err, req, res, next) => {
      console.error('‚ùå Erreur serveur:', err.message);
      res.status(500).json({ 
        success: false,
        message: 'Erreur interne serveur',
        error: process.env.NODE_ENV === 'development' ? err.message : 'Internal Server Error'
      });
    });

    console.log('‚úÖ Toutes les routes charg√©es avec succ√®s');
    return true;

  } catch (error) {
    console.error('‚ùå Erreur lors du chargement des routes:', error.message);
    console.error('Stack:', error.stack);
    return false;
  }
};

// ----- D√©marrage de l'application -----
const startServer = async () => {
  try {
    console.log('üöÄ === D√âMARRAGE TEAMTASK BACKEND ===');
    
    // 1. Connexion √† MongoDB D'ABORD
    console.log('üîÑ √âtape 1: Connexion √† MongoDB...');
    const isConnected = await connectDB();
    if (!isConnected) {
      console.error('‚ùå Impossible de se connecter √† MongoDB. Arr√™t du serveur.');
      process.exit(1);
    }
    console.log('‚úÖ √âtape 1 termin√©e: MongoDB connect√©');

    // 2. Chargement des routes APR√àS connexion DB r√©ussie
    console.log('üîÑ √âtape 2: Chargement des routes et mod√®les...');
    const routesLoaded = await loadRoutes();
    if (!routesLoaded) {
      console.error('‚ùå Impossible de charger les routes. Arr√™t du serveur.');
      process.exit(1);
    }
    console.log('‚úÖ √âtape 2 termin√©e: Routes et mod√®les charg√©s');

    // 3. D√©marrage du serveur HTTP
    console.log('üîÑ √âtape 3: D√©marrage du serveur HTTP...');
    const PORT = process.env.PORT || 5000;
    
    const server = app.listen(PORT, () => {
      console.log(`\nüéâ === TEAMTASK BACKEND D√âMARR√â AVEC SUCC√àS ===`);
      console.log(`üöÄ Serveur disponible sur: http://localhost:${PORT}`);
      console.log(`‚úÖ MongoDB: ${mongoose.connection.readyState === 1 ? 'Connect√©' : 'D√©connect√©'}`);
      console.log(`‚úÖ Base de donn√©es: ${mongoose.connection.name}`);
      
      console.log('\nüìù Routes API disponibles:');
      console.log('   üîê Authentification:');
      console.log('      - POST /api/auth/register');
      console.log('      - POST /api/auth/login');
      console.log('   üìã T√¢ches:');
      console.log('      - GET/POST/PUT/DELETE /api/tasks/*');
      console.log('   üìä Historique:');
      console.log('      - GET /api/history (avec auth)');
      console.log('      - GET /api/history/task/:taskId');
      console.log('      - GET /api/history/stats');
      console.log('   üë• Utilisateurs:');
      console.log('      - GET /api/users');
      console.log('   üß™ Test/Debug:');
      console.log('      - GET /test');
      console.log('      - GET /debug-users');
      console.log('      - GET /debug-history');
      console.log('      - GET /test-taskhistory-direct');
      console.log('      - GET /api/history-no-auth');
      console.log('      - POST /api/history-test-create');
      
      console.log('\nüéØ Pour tester TaskHistory:');
      console.log(`   curl http://localhost:${PORT}/debug-history`);
      console.log(`   curl http://localhost:${PORT}/test-taskhistory-direct`);
      
      console.log('\n‚úÖ TeamTask Backend est pr√™t et op√©rationnel !');
    });

    // Gestion propre de l'arr√™t
    process.on('SIGINT', async () => {
      console.log('\nüõë Arr√™t du serveur...');
      server.close(async () => {
        await mongoose.connection.close();
        console.log('üëã Serveur arr√™t√© proprement');
        process.exit(0);
      });
    });

  } catch (error) {
    console.error('‚ùå Erreur fatale lors du d√©marrage:', error.message);
    console.error('Stack:', error.stack);
    process.exit(1);
  }
};

// Gestion des erreurs globales
process.on('uncaughtException', (error) => {
  console.error('‚ùå Erreur non captur√©e:', error.message);
  console.error('Stack:', error.stack);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('‚ùå Promise rejet√©e:', reason);
  console.error('Promise:', promise);
  process.exit(1);
});

// D√©marrer l'application
startServer();